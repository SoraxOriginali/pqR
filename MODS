This file records modifications in pqR that are of little interest to
users, such as cleanups of source code.

   o Cleaned up inconsistencies in checks for arity of primitives in eval.c
     Removed checks from functions implementing language features "repeat",
     "while", and "function", consistent with other language features (lack
     of checks does not cause a crash --- missing arguments just appear
     to be NULL).  Changed the check in do_set to the standard form
     using checkArity, with names.c changed to make the arity be 2 rather
     than -1.

   o The "spare" bit in sxpinfo is renamed to "misc", and the documentation 
     in the code and in R-ints.texi is changed to reflect this, and to 
     document that this bit is actually used.

   o The documentation before do_seq in seq.c is changed to be correct
     (seq.int is no longer SPECIAL), and the incorrect reference to
     seq.int in R-ints.texi is removed.

   o The fixup_NaRm function defined in summary.c is moved to match.c,
     where it belongs.  It is now properly declared in Rinternals.h,
     rather than the definition in summary.c being surreptitiously
     referenced as an extern from logic.c.

  5)

   o New functions are defined for finding exact or partial matches,
     to replace the existing pmatch, psmatch, and other matching
     functions (but pmatch and psmatch are retained, in case anyone
     uses them).  These functions return 0, -1, or +1 for no match,
     partial match, and exact match, allowing any subset of these
     conditions to be easily checked for in one comparison.  There is
     therefore no need for an "exact" argument as in psmatch.  The new
     functions should usually be faster as well (the old psmatch uses
     strcmp for exact matches, which might be able to use special
     machine instructions if they exist, but since most calls will be
     for short strings, and early failure to match is likely the most
     common result, this is unlikely to provide a benefit once extra
     procedure call overhead is accounted for.)

     Versions are provided for matching a string to a string, an SEXP
     to an SEXP, or a string to an SEXP, called ep_match_strings,
     ep_match_exprs, and ep_match_string_expr.

     Calls of pmatch are replaced by calls of ep_match_exprs in
     various places.  The modified versions of matchArgs and in
     do_subset3 (implementing $), describe elsewhere, also use these
     new functions.

  7)

   o New functions copy_string_elements and copy_vector_elements are now
     defined.  Compared to using SET_STRING_ELT and SET_VECTOR_ELT, these
     allow copying of multiple elements without error checks on every element, 
     and sometimes without old-to-new checks on every element.  A new function
     copy_elements is also defined, for copying elements in any sort of vector
     (duplicating non-atomic elements, and using copy_string_elements).

  9)

   o Created a promiseArgsWithValues function that calls promiseArgs
     and then sets the values of the promises created, and a
     promiseArgsWith1Value function that does the same except setting
     only the value for the first promise.  Code to do these things
     appears in several places, so creating these functions cleans
     things up (and is needed for later mods).

     The promiseArgsWithValues and promiseArgsWith1Value functions are
     not entirely equivalent to the previous code, which set the
     values of what it took to be promises without checking that they
     actually were promises.  Since promiseArgs doesn't always create
     a promise for every argument (it doesn't when the argument is
     R_MissingArg), this doesn't seem safe, though I haven't found an
     example where a bug actually arises.  The promiseArgsWithValues
     and promiseArgsWith1Value silently skip setting the value for
     arguments that aren't promises, as will be necessary when missing
     arguments do arise.

   o Fixed a problem with the DispatchOrEval function in eval.c.
     Without this fix, some subtle things go wrong with existing
     features in 2.15.0, and more serious things go wrong with some of
     other mods in pqR.

     The issue is that if DispatchOrEval is called with argsevald set
     to 1 (indicating that arguments have already been evaluated), if
     DispatchOrEval dispatches to a method for an object, it passes on
     these argument values without putting them in promises along with
     the unevaluated arguments.  Because of this, a method that
     attempts to deparse an argument will not work correctly.  It
     seems possible that there might also be some other bad effects of
     not having these promises.

     Here is an illustration:

     > a <- 0
     > class(a) <- "fred"
     > seq.fred <- function (x, y) deparse(substitute(y))
     > seq(a,1+2)
     [1] "1 + 2"
     > seq.int(a,1+2)
     [1] "3"

     Both "seq" and "seq.int" dispatch to seq.fred, but seq.int calls
     DispatchOrEval, which doesn't pass on a promise with the
     unevaluated argument.  After the fix, seq.int does the same as seq.
     This example is now tested in tests/eval-etc.R.

     Also fixed some formatting in DispatchOrEval, and improved the
     documentation for R_possible_dispatch to explain its features
     used in this fix.

 12)

 13) A facility has been introduced for an expression to be evaluated
     in a context in which a "variant result" is allowed - eg, if the
     result will be ignored anyway (expression is evaluated only for
     side effects), a null result might be allowed.  This is done by
     introducing an "evalv" function that is like "eval" but with an
     extra parameter saying what variant results are permissible.
     This facility is used for some modifications noted elsewhere.

 14) Calling of primitive functions has been speeded up by copying
     relevant information (eg, arity) from the table defining
     primitives (in names.c) to fields in the SEXP for the primitive.
     This saves table access computations and also division and
     remainder operations to get at the information in the "eval"
     field in names.c, which is encoded as decimal digits.  

     A procedure SET_PRIMFUN in memory.c was surreptitiously changing
     the function pointer for a primitive via the function pointer
     access macro, PRIMFUN.  I have introduced a SET_PRIMFUN macro to
     do this properly.

     Code in saveload.c (for loading old workspaces?) creates a
     primitive directly, bypassing the mkPRIMSXP procedure.  This
     seems unwise, since creation via mkPRIMSXP is apparently needed
     to ensure protection of primitives.  Whatever is going on there
     should not be affected by this modification, however.

 15)

 16)

 17)

   o The matchArgs function, used in the interpreter to match 
     formal and actual arguments when calling functions has been
     sped up, and given a new interface.

     One interface change allows the formal arguments to either be
     given as a list SEXP (as before), or as an array of C strings,
     along with a count of how many strings are in the array.  (If
     formals are given by C strings, the SEXP for the formals list
     parameter should be NULL, whereas if the formals are given by a
     list, the pointer for the C strings should be NULL and their
     count should be 0.)

     Numerous calls of matchArgs are changed to use the interface with
     an array of C strings (for example, in the code implementing rep
     and seq.int).  These calls were previously preceded by creation
     of a list with calls to "install" for all the formal argument
     names.  Using the new interface is cleaner and considerably
     faster.

     A second interface change is that if the formals are given by a
     list SEXP, tags for the arguments are attached to the actuals
     list by matchArgs.  Places where matchArgs is called are changed
     to no longer do this themselves.  (Doing this in matchArgs is
     both cleaner and faster.)

     The new code is also faster in ways unrelated to these interface
     changes.

 19)

 20)

 21)

 22)

 23)

 24)

 25)

   o Rinternals.h now has a #define for R_OMP_FIRSTPRIVATE_VARS, which 
     contains a comma-separated list of variables that should usually
     be included in the firstprivate part of an OMP parallel construction,
     since they are used in macros such as NA_REAL.

 27)

 28)

 29)

 30) The 38 calls of check1arg(args,call,"x") were replaced with calls
     of a new macro check1arg_x(args,call) that should be faster.

 31)

 32)

 33)

   o Code in R-2.15.0 exists for maintaining a cache of primitive objects,
     but this code forgets to ever actually enter a primitve into the cache.
     This is now done (in mkPRIMSXP).

 35)

 36)

 37)

   o The "inspect" .Internal function was changed to show some details of
     pairlist nodes, if SHOW_PAIRLIST_NODES is defined as 1 in inspect.c.
     Also, it no longer produces output with tabs (spaces instead).

 39)

 40)

 41)

 42)

 43)

 44)

 45)

 46)

 47)

 48)

 49)

 50)

 51)

 52)

 53)

 54)

 55)

 56)

 57)

 58)

 59)

 60)

 61)

 62)

 63)

 64)

 65)

 66)

 67)

 68)

 69)

 70)

 71)

 72)

 73)

 74)

 75)

 76)

 77)

 78)

 79)

 80)

 81)

 82)

 83)

 84)

 85)

 86)

 87)

 88)

 89)

 90)

 91)

 92)

 93)

 94)

 95)

 96)

 97)

 98)

 99)
